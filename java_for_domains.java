package com.smdi.flack.model.eo.common;

import java.io.Serializable;

import oracle.jbo.Transaction;
import oracle.jbo.domain.DomainInterface;
import oracle.jbo.domain.DomainOwnerInterface;
// ------------------------------------------------------------------------------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Wed Dec 21 15:43:34 EST 2016
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.


//  I've recently had the need to create an ADF application against a PostgreSQL database.  
//  This isn't exactly supported, but you can use it as a Generic JDBC database.  
//  To do this, create a Library in the Manage Libraries tool in JDeveloper and add the JAR for the PostgreSQL JDBC driver.  
//  When you create the database connection, choose "Generic JDBC" as the Connection Type, set the Driver Class to org.postgresql.Driver 
//  and the Library to the library for the JDBC driver.  My JDBC URL is "jdbc:postgresql://localhost/flack" for the flack database on my workstation.
//  The problem is when you do "Business Components from Tables" in the ADF Model project, some datatypes don't get mapped properly.  
//  In particular, even if your CREATE TABLE for creating a PostgreSQL table listed a column as the ANSI SQL type, INTEGER, PostgreSQL creates it as "int4".  
//  It does the same with identity columns that in PostgreSQL get the datatype, "serial".  SMALLINT gets created as "int2".  
//  The wizard wants to create Entity Objects with these attributes as Domains - and creates Java classes for the domains.  
//  Worse still, the Domains are mapped to Strings, not Integers.
//  One way to handle this is to modify the Java for the domains.  I created my own domain, 
//  TempInt that maps to an Integer to use as an example of what the Int4 and Serial domains SHOULD appear, 
//  then modified the code for the generated domains to look like TempInt.  Here is the resulting code for the Int4 domain:


// ------------------------------------------------------------------------------------------------------------------------------------------
public class Int4 implements DomainInterface, Serializable {
    public Int4(int val) {
        mData = new Integer(val);
        validate();
    }

    public Int4(String obj) {
        mData = (new Integer(obj));
        validate();
    }

    public Int4(Integer obj) {
        mData = obj;
        validate();
    }
    private Integer mData;

    protected Int4() {
        mData = null;
    }

    public Object getData() {
        return mData;
    }

    /**
     * <b>Internal:</b> <em>Applications should not use this method.</em>
     */
    public void setContext(DomainOwnerInterface owner, Transaction trans,
                           Object obj) {
    }

    /**
     * Implements domain validation logic and throws a JboException on error.
     */
    protected void validate() {
        //  ### Implement custom domain validation logic here. ###
    }

    public String toString() {
        if (mData != null) {
            return mData.toString();
        }
        return "<null>";
    }

    public boolean equals(Object obj) {
        if (obj instanceof DomainInterface) {
            if (mData != null) {
                return mData.equals(((DomainInterface)obj).getData());
            }
            return ((DomainInterface)obj).getData() == null;
        }
        return false;
    }
}
